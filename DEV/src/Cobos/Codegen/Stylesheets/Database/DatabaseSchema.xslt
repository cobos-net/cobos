<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0"
						xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
						xmlns:msxsl="urn:schemas-microsoft-com:xslt"
						exclude-result-prefixes="msxsl"
						xmlns="http://schemas.cobos.co.uk/datamodel/1.0.0"
						xmlns:cobos="http://schemas.cobos.co.uk/datamodel/1.0.0"
						xmlns:xsd="http://www.w3.org/2001/XMLSchema"
>
  
	<xsl:output method="xml" indent="yes"/>

	<!-- 
	=============================================================================
	Filename: DatabaseSchema.xslt
	Description: Create an XML schema from the raw XML metadata.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Created by: N.Davis                        Date: 2010-04-09
	Modified by:                               Date:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Notes: 


	============================================================================
	-->

	<!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Keys for grouping metadata elements.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

  <!-- string length data types -->
  <xsl:key name="stringLengths" match="COLUMN[./DATA_TYPE = 'CHAR' or ./DATA_TYPE = 'NCHAR' or ./DATA_TYPE = 'VARCHAR2' or ./DATA_TYPE = 'VARCHAR' or ./DATA_TYPE = 'NVARCHAR2' or ./DATA_TYPE = 'NVARCHAR' or ./DATA_TYPE = 'VARBINARY']" use="CHARACTER_MAXIMUM_LENGTH"/>
  <!-- raw field length data types -->
  <xsl:key name="rawLengths" match="COLUMN[./DATA_TYPE = 'RAW' or ./DATA_TYPE = 'LONGRAW']" use="CHARACTER_OCTET_LENGTH"/>
  <!-- constraint names -->
	<xsl:key name="constraintNames" match="CONSTRAINT" use="CONSTRAINT_NAME"/>
	
	<!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Process the metadata.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

	<xsl:template match="/TABLE_METADATA">
    <xsl:text disable-output-escaping="yes"><![CDATA[
<!--
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 <auto-generated>
	  This code was generated by a tool.

	  Changes to this file may cause incorrect behavior and will be lost if
	  the code is regenerated.
 </auto-generated>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This schema was auto-generated by Cobos SDK tools.
-->
]]></xsl:text>    
		<xsd:schema 
        targetNamespace="http://schemas.cobos.co.uk/datamodel/1.0.0"
				xmlns="http://schemas.cobos.co.uk/datamodel/1.0.0"
				xmlns:cobos="http://schemas.cobos.co.uk/datamodel/1.0.0"
				xmlns:xsd="http://www.w3.org/2001/XMLSchema"
				elementFormDefault="qualified">
      
			<xsd:simpleType name="char">
				<xsd:restriction base="xsd:byte">
				</xsd:restriction>
			</xsd:simpleType>

      <xsd:simpleType name="bitField">
        <xsd:restriction base="xsd:string">
        </xsd:restriction>
      </xsd:simpleType>

      <xsd:simpleType name="timestamp">
        <xsd:restriction base="xsd:dateTime">
          <xsd:minInclusive value="1970-01-01T00:00:01Z"/>
          <xsd:maxInclusive value="2038-01-19T03:14:07Z"/>
        </xsd:restriction>
      </xsd:simpleType>      
      
      <xsl:for-each select="//COLUMN[./DATA_TYPE = 'CHAR' or ./DATA_TYPE = 'NCHAR' or ./DATA_TYPE = 'VARCHAR2' or ./DATA_TYPE = 'VARCHAR' or ./DATA_TYPE = 'NVARCHAR2' or ./DATA_TYPE = 'NVARCHAR' or ./DATA_TYPE = 'VARBINARY'][generate-id() = generate-id(key('stringLengths',CHARACTER_MAXIMUM_LENGTH)[1])]">
        <xsl:sort select="CHARACTER_MAXIMUM_LENGTH" data-type="number"/>
        <xsl:variable name="length">
          <xsl:value-of select="CHARACTER_MAXIMUM_LENGTH"/>
        </xsl:variable>
        <xsd:simpleType name="string_{$length}">
          <xsd:restriction base="xsd:string">
            <xsd:maxLength value="{$length}"/>
          </xsd:restriction>
        </xsd:simpleType>
      </xsl:for-each>

      <xsl:for-each select="//COLUMN[./DATA_TYPE = 'RAW'][generate-id() = generate-id(key('rawLengths',CHARACTER_OCTET_LENGTH)[1])]">
        <xsl:sort select="CHARACTER_OCTET_LENGTH" data-type="number"/>
        <xsl:variable name="length">
          <xsl:value-of select="CHARACTER_OCTET_LENGTH"/>
        </xsl:variable>
        <xsd:simpleType name="hexBinary_{$length}">
          <xsd:restriction base="xsd:hexBinary">
            <xsd:length value="{$length}"/>
          </xsd:restriction>
        </xsd:simpleType>
      </xsl:for-each>

      <xsd:element name="Tables">
				<xsd:complexType>
					<xsd:sequence>
						<xsl:apply-templates select="TABLE" mode="column"/>
					</xsd:sequence>
				</xsd:complexType>
				<xsl:apply-templates select="TABLE" mode="constraint"/>
			</xsd:element>
		</xsd:schema>

	</xsl:template>
  
  <!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Table Columns.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

	<xsl:template match="TABLE" mode="column">
		<xsd:element name="{NAME}">
			<xsd:complexType>
				<xsd:sequence>
					<xsl:apply-templates select="COLUMN"/>
				</xsd:sequence>
			</xsd:complexType>
		</xsd:element>
	</xsl:template>

	<!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Table Constraints.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

	<xsl:template match="TABLE" mode="constraint">
		<xsl:for-each select="CONSTRAINT[generate-id() = generate-id(key('constraintNames',CONSTRAINT_NAME)[1])]">
			<xsl:apply-templates select="."/>
		</xsl:for-each>
	</xsl:template>

	<!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Column.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

	<xsl:template match="COLUMN">
		<xsl:element name="xsd:element">
			<xsl:attribute name="name">
				<xsl:value-of select="COLUMN_NAME"/>
			</xsl:attribute>
			<xsl:attribute name="type">
				<xsl:apply-templates select="DATA_TYPE"/>
			</xsl:attribute>
			<xsl:attribute name="minOccurs">
				<xsl:apply-templates select="IS_NULLABLE"/>
			</xsl:attribute>
		</xsl:element>
	</xsl:template>

	<!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Nullable types.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

	<xsl:template match="IS_NULLABLE[. = 'YES']">
		<xsl:text>0</xsl:text>
	</xsl:template>

	<xsl:template match="IS_NULLABLE[. = 'NO']">
		<xsl:text>1</xsl:text>
	</xsl:template>
  
  <!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Numeric Types - Integer.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

  <xsl:template match="DATA_TYPE[. = 'NUMBER']">
    <xsl:text>xsd:integer</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'TINYINT']">
    <xsl:text>xsd:byte</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'SMALLINT']">
    <xsl:text>xsd:short</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'MEDIUMINT']">
    <xsl:text>xsd:int</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'INT']">
    <xsl:text>xsd:int</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'BIGINT']">
    <xsl:text>xsd:long</xsl:text>
  </xsl:template>

  <!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Numeric Types - Fixed point.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

  <xsl:template match="DATA_TYPE[. = 'DECIMAL']">
    <xsl:text>xsd:decimal</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'NUMERIC']">
    <xsl:text>xsd:decimal</xsl:text>
  </xsl:template>

  <!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Numeric Types - Floating point.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

  <xsl:template match="DATA_TYPE[. = 'FLOAT' or . = 'BINARY_FLOAT']">
    <xsl:text>xsd:float</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'DOUBLE' or . = 'BINARY_DOUBLE']">
    <xsl:text>xsd:double</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'REAL']">
    <xsl:text>xsd:double</xsl:text>
  </xsl:template>

  <!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Bit Fields.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

  <xsl:template match="DATA_TYPE[. = 'BIT']">
    <xsl:text>xsd:boolean</xsl:text>
  </xsl:template>

  <!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Character Types.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

  <xsl:template match="DATA_TYPE[. = 'CHAR' or . = 'NCHAR' or . = 'VARCHAR' or . = 'VARCHAR2' or . = 'NVARCHAR' or . = 'NVARCHAR2' or . = 'VARBINARY']">
    <xsl:value-of select="concat( 'string_', ../CHARACTER_MAXIMUM_LENGTH )"/>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'TEXT' or . = 'TINYTEXT' or . = 'MEDIUMTEXT' or . = 'LONGTEXT' or . = 'CLOB']">
    <xsl:text>xsd:string</xsl:text>
  </xsl:template>

  <!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Date Time.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

  <xsl:template match="DATA_TYPE[. = 'DATE']">
    <xsl:text>xsd:date</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'DATETIME']">
    <xsl:text>xsd:dateTime</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'TIME']">
    <xsl:text>xsd:time</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'TIMESTAMP']">
    <xsl:text>cobos:timestamp</xsl:text>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'YEAR']">
    <xsl:text>xsd:gYear</xsl:text>
  </xsl:template>


  <!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	BLOB.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

  <xsl:template match="DATA_TYPE[. = 'RAW' or . = 'LONGRAW']">
    <xsl:value-of select="concat('hexBinary_', ../CHARACTER_OCTET_LENGTH)"/>
  </xsl:template>

  <xsl:template match="DATA_TYPE[. = 'BLOB' or . = 'TINYBLOB' or . = 'MEDIUMBLOB' or . = 'LONGBLOB' or . = 'LONG RAW']">
    <xsl:text>xsd:hexBinary</xsl:text>
  </xsl:template>

  <!--
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Constraints.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-->

	<!-- primary key -->
	<xsl:template match="CONSTRAINT[CONSTRAINT_TYPE = 'PRIMARY KEY']">
		<xsd:key name="{CONSTRAINT_NAME}">
			<xsd:selector xpath=".//{../NAME}"/>
			<xsl:apply-templates select=".
													| preceding-sibling::CONSTRAINT[CONSTRAINT_NAME = current()/CONSTRAINT_NAME]
													| following-sibling::CONSTRAINT[CONSTRAINT_NAME = current()/CONSTRAINT_NAME]" 
										mode="field"/>
		</xsd:key>
	</xsl:template>

	<!-- unique key -->
	<xsl:template match="CONSTRAINT[CONSTRAINT_TYPE = 'UNIQUE']">
		<xsd:unique name="{CONSTRAINT_NAME}">
			<xsd:selector xpath=".//{../NAME}"/>
			<xsl:apply-templates select=".
													| preceding-sibling::CONSTRAINT[CONSTRAINT_NAME = current()/CONSTRAINT_NAME]
													| following-sibling::CONSTRAINT[CONSTRAINT_NAME = current()/CONSTRAINT_NAME]"
										mode="field"/>
		</xsd:unique>
	</xsl:template>

	<!-- foreign key -->
	<xsl:template match="CONSTRAINT[CONSTRAINT_TYPE = 'FOREIGN KEY']">
		<!-- not yet supported -->
	</xsl:template>

	<!-- field element -->
	<xsl:template match="CONSTRAINT" mode="field">
		<xsd:field xpath ="{COLUMN_NAME}"/>
	</xsl:template>

</xsl:stylesheet>
