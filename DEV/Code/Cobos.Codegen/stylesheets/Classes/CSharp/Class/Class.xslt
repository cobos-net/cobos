<xsl:stylesheet version="1.0"						xmlns:xsl="http://www.w3.org/1999/XSL/Transform"						xmlns:msxsl="urn:schemas-microsoft-com:xslt"						exclude-result-prefixes="msxsl"						xmlns="http://schemas.cobos.co.uk/datamodel/1.0.0"						xmlns:cobos="http://schemas.cobos.co.uk/datamodel/1.0.0"						xmlns:xsd="http://www.w3.org/2001/XMLSchema">	<xsl:include href="./Body.xslt"/>	<xsl:include href="./Members.xslt"/>	<xsl:include href="./Constructor.xslt"/>	<xsl:include href="./IDisposable.xslt"/>	<!-- 	=============================================================================	Filename: Class.xslt	Description: Create a class definition for each object.	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	Created by: N.Davis                        Date: 2010-04-09	Modified by:                               Date:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	Notes: 			============================================================================	-->		<!--	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	Top level class	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	-->		<xsl:template match="cobos:Object[ parent::cobos:DataModel ]" mode="classDefinition">			[DataContract(Namespace="<xsl:value-of select="$xmlNamespace"/>")]	public partial class <xsl:value-of select="@name"/> <xsl:apply-templates select="." mode="classInheritance"/>	{		<xsl:apply-templates select="." mode="classBody"/>		<xsl:apply-templates select="." mode="classIDisposable"/>	}		</xsl:template>	<!--	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	Interface - declared as an abstract class	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	-->	<xsl:template match="cobos:Interface[ @isAbstractClass = 'true' ]" mode="classDefinition">	[DataContract(Namespace="<xsl:value-of select="$xmlNamespace"/>")]	public abstract partial class <xsl:value-of select="@name"/>	{		<xsl:apply-templates select="." mode="classBody"/>	}	</xsl:template>		<!--	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	Interface - declared as an interface	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	-->	<xsl:template match="cobos:Interface[ not( @isAbstractClass = 'true' ) ]" mode="classDefinition">	[DataContract(Namespace="<xsl:value-of select="$xmlNamespace"/>")]	public interface <xsl:value-of select="@name"/>	{		<xsl:apply-templates select="." mode="classBody"/>	}	</xsl:template>		<!--	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	Nested class	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	-->	<xsl:template match="cobos:Object[ parent::cobos:Object | parent::cobos:Interface ]" mode="classDefinition">	[DataContract(Namespace="<xsl:value-of select="$xmlNamespace"/>")]	public <xsl:apply-templates select="." mode="classQualifiers"/> <xsl:value-of select="@typeName"/> <xsl:apply-templates select="." mode="classInheritance"/>	{		<xsl:apply-templates select="." mode="classBody"/>	}	</xsl:template>		<!--	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	Class qualifiers for nested classes within abstract interfaces	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	-->	<xsl:template match="cobos:Object[ ancestor::cobos:Interface[ not( @isAbstractClass = 'true' ) ] ]" mode="classQualifiers">		<xsl:text>interface </xsl:text>	</xsl:template>	<xsl:template match="cobos:Object[ ancestor::cobos:Interface[ @isAbstractClass = 'true' ] ]" mode="classQualifiers">		<xsl:text>abstract partial class </xsl:text>	</xsl:template>	<xsl:template match="cobos:Object[ not( ancestor::cobos:Interface ) and not( ancestor::cobos:Object/@implements ) ]" mode="classQualifiers">		<xsl:text>class </xsl:text>	</xsl:template>	<xsl:template match="cobos:Object[ not( ancestor::cobos:Interface ) and ancestor::cobos:Object/@implements ]" mode="classQualifiers">		<!-- get the interface object the parent class implements -->		<xsl:variable name="interface" select="/cobos:DataModel/cobos:Interface[ @name = current()/ancestor-or-self::cobos:Object[ @implements ]/@implements ]"/>		<!-- only apply if the new keyword if this class is defined in thes base class -->		<xsl:variable name="property" select="$interface//cobos:Object[ substring-after( @qualifiedName, '.' ) = substring-after( current()/@qualifiedName, '.' ) ]"/>		<xsl:choose>			<xsl:when test="$property">				<xsl:text>new class </xsl:text>			</xsl:when>			<xsl:otherwise>				<xsl:text>class </xsl:text>			</xsl:otherwise>		</xsl:choose>	</xsl:template>	<!--	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	Class Inheritance	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	-->	<!-- top level objects implements IDisposable and abstract class or interface -->	<xsl:template match="cobos:Object[ parent::cobos:DataModel and @implements ]" mode="classInheritance">		<xsl:text> : </xsl:text>		<xsl:value-of select="@implements"/>		<xsl:text>, IDisposable </xsl:text>	</xsl:template>	<!-- top level object that does not inherit or implement an interface -->	<xsl:template match="cobos:Object[ parent::cobos:DataModel and not( @implements ) ]" mode="classInheritance">		<xsl:text> : IDisposable</xsl:text>	</xsl:template>	<!-- nested object within a class that implements an interface or inherits an abstract class -->	<xsl:template match="cobos:Object[ not( parent::cobos:DataModel ) and ancestor-or-self::cobos:Object[ @implements ] ]" mode="classInheritance">		<!-- get the interface object the parent class implements -->		<xsl:variable name="interface" select="/cobos:DataModel/cobos:Interface[ @name = current()/ancestor-or-self::cobos:Object[ @implements ]/@implements ]"/>		<!-- only apply if this property is defined in the abstract class -->		<xsl:apply-templates select="$interface//cobos:Object[ substring-after( @qualifiedName, '.' ) = substring-after( current()/@qualifiedName, '.' ) ]" mode="classInheritanceDeclaration"/>	</xsl:template>	<xsl:template match="cobos:Object" mode="classInheritanceDeclaration">		<xsl:text> : </xsl:text>		<xsl:value-of select="@qualifiedTypeName"/>	</xsl:template>	</xsl:stylesheet>